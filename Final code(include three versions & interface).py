# -*- coding: utf-8 -*-
"""互動式音訊

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1weSQK-zvyG4YLc9iPew3EkzQ0O5hurOK
"""

!pip install pyts
!pip install pretty_midi

!pip list|grep pyts

import collections
from music21 import converter, instrument, note, stream
import numpy as np
from matplotlib import pyplot as plt

def midi_to_notes(file):
  midi = converter.parse(file)
  lst = []
  for i in midi.parts:
    for j in i:
      if isinstance(j, note.Note):
        lst.append(j.pitch.midi)
  return lst

def midi_to_durations(file):
  midi = converter.parse(file)
  print(midi)
  lst = []
  onset = 0
  c = 0
  start = False
  for i in midi.parts:
    for j in i:
      print(j, end = " ")
      if isinstance(j, note.Note):
        start = True
        print(j.duration.quarterLength, end = " ")
        lst.append(onset)
        onset += j.duration.quarterLength
      elif isinstance(j, note.Rest):
        print("Rest", end = " ")
        print(j.duration.quarterLength, end = " ")
        if(start):
          
          onset += j.duration.quarterLength
          c += 1
      print()
    break
  print(c)
  return lst

score = midi_to_notes("./USER6_TEST.mid")
input = midi_to_notes("./USER_BackToStartBar.mid")

#score_d = midi_to_durations("./USER6_TEST.mid")
temp = midi_to_durations("./USER6_TEST.mid")
print(len(score))
print(len(input))
print(temp)

import numpy as np
import matplotlib.pyplot as plt

from pyts.metrics import dtw, itakura_parallelogram, sakoe_chiba_band
from pyts.metrics.dtw import (cost_matrix, accumulated_cost_matrix,
                              _return_path, _blurred_path_region)


n_timestamps_1 = len(score)
n_timestamps_2 = len(input)
plt.figure(figsize=(10, 8))
timestamps_1 = np.arange(n_timestamps_1 + 1)
timestamps_2 = np.arange(n_timestamps_2 + 1)

# Dynamic Time Warping: classic
dtw_classic, path_classic = dtw(score, input, dist='absolute', method='classic', return_path=True)
matrix_classic = np.zeros((n_timestamps_1, n_timestamps_2))
matrix_classic[tuple(path_classic)] = 1.

plt.subplot(2, 2, 1)
plt.pcolor(timestamps_2, timestamps_1, matrix_classic, edgecolors='k', cmap='Greys')
plt.xlabel('x', fontsize=12)
plt.ylabel('y', fontsize=12)
plt.title("{0}\nDTW(x, y) = {1:.2f}".format('classic', dtw_classic), fontsize=14)

print(len(input[39:]))

# from tables import path
def dtw_path(score, score_d, input, gap, constraint):
  lst = [[], []]
  finish = False
  score_temp = score.copy()
  input_temp = input.copy()

  bar_start = []

  thr = 0 
  for i in range(len(score_d)):  
    if(score_d[i] >= thr):
      bar_start.append(i) # 加一個終止?
      thr += 3
  
  start = 0      
  
  while(not finish):
    in_bar = False
    for i in range(len(bar_start)):
      print("start at " + str(start))
      print("comparing to bar " + str(i))
      print()
      
      s, path = dtw(score_temp[bar_start[i]:], input_temp[start:], dist='absolute', method='classic', return_path=True)
      for j in range(len(path[0]) - gap):
        slope = -1
        if(path[0][j+gap] != path[0][j]):
          slope = abs(path[1][j+gap] - path[1][j]) / abs(path[0][j+gap] - path[0][j])
        # print(slope)
        if(slope < constraint or slope > (1/constraint)):
          start += j
              
          break
        else:
          in_bar = True
          lst[0].append(path[0][j] + bar_start[i])
          lst[1].append(path[1][j] + start)
          if(j == len(path[0]) - gap - 1):
            for k in range(gap):
              lst[0].append(path[0][j + k + 1] + bar_start[i])
              lst[1].append(path[1][j + k + 1] + start)
            finish = True
      
      if(in_bar):
        break

      if(finish):
        break


  return lst

x = dtw_path(score, score_d, input, 5, 3/5)

n_timestamps_1 = len(score)
n_timestamps_2 = len(input)
plt.figure(figsize=(10, 8))
timestamps_1 = np.arange(n_timestamps_1 + 1)
timestamps_2 = np.arange(n_timestamps_2 + 1)
matrix_classic = np.zeros((n_timestamps_1, n_timestamps_2))
matrix_classic[tuple(x)] = 1.

plt.subplot(2, 2, 1)
plt.pcolor(timestamps_2, timestamps_1, matrix_classic, edgecolors='k', cmap='Greys')
plt.xlabel('x', fontsize=12)
plt.ylabel('y', fontsize=12)
#plt.title("{0}\nDTW(x, y) = {1:.2f}".format('classic', dtw_classic), fontsize=14)

bar_start = []

thr = 0 
for i in range(len(score_d)):  
  if(score_d[i] >= thr):
    bar_start.append(i) # 加一個終止?
    thr += 3
print(bar_start)

def DTW(score, input):
  row_num = len(score)
  col_num = len(input)
  # print(row_num, col_num)
  cost = np.zeros((row_num, col_num))

  for i in range(row_num):
    for j in range(col_num):
      cost[i][j] = abs(score[i] - input[j])
  
  lst = []
  c_point = [0, 0]
  print([row_num-1, col_num-1])
  while(c_point != [row_num-1, col_num-1]):
    lst.append(c_point)
    c_row = c_point[0]
    c_col = c_point[1]

    row_inc = c_row+1
    if(row_inc == row_num):
      c_point = [c_row, c_col+1]
      continue      

    col_inc = c_col+1
    if(col_inc == col_num):
      c_point = [c_row+1, c_col]
      continue
    

    #print(c_row, c_col, row_inc, col_inc)
    cost_array = [cost[row_inc, c_col], cost[c_row, col_inc], cost[row_inc, col_inc]]
    
    a = np.array(cost_array)
    
    index = np.argmin(a)
    if(a[index] == a[2]):
      index = 2

    if(index == 0):
      c_point = [row_inc, c_col]
    elif(index == 1):
      c_point = [c_row, col_inc]
    else:
      c_point = [row_inc, col_inc]

    # print(c_point)
  lst.append(c_point)
  #print(lst)  
  return lst

lst = DTW(score, input)

x = [[], []]


for i in lst:
  x[0].append(i[0])
  x[1].append(i[1])

n_timestamps_1 = len(score)
n_timestamps_2 = len(input)
plt.figure(figsize=(10, 8))
timestamps_1 = np.arange(n_timestamps_1 + 1)
timestamps_2 = np.arange(n_timestamps_2 + 1)
matrix_classic = np.zeros((n_timestamps_1, n_timestamps_2))
matrix_classic[tuple(x)] = 1.

plt.subplot(2, 2, 1)
plt.pcolor(timestamps_2, timestamps_1, matrix_classic, edgecolors='k', cmap='Greys')
plt.xlabel('x', fontsize=12)
plt.ylabel('y', fontsize=12)

# from tables import path
def dtw_path2(score, score_d, input, gap, constraint):
  lst = [[], []]
  finish = False
  score_temp = score.copy()
  input_temp = input.copy()

  bar_start = []

  thr = 0 
  for i in range(len(score_d)):  
    if(score_d[i] >= thr):
      bar_start.append(i) # 加一個終止?
      thr += 3
  bar_start.append(len(score))
  
  print(bar_start)
  two_bar = -1
  one_bar = -1

  for i in range(len(bar_start) - 2):
    l = bar_start[i+2] - bar_start[i]
    if(l > two_bar):
      two_bar = l

  for i in range(len(bar_start) - 1):
    l = bar_start[i+1] - bar_start[i]
    if(l > one_bar):
      one_bar = l


  print("max num in 2 bars : ", two_bar)
  
  
  input_start = 0
  score_start_index = 0
  
  head = 0
  while(not finish):
    print("input start at : ", head)

    l = min(len(input[head:]), two_bar)
    s, path = dtw(score_temp[bar_start[0]:bar_start[2]], input_temp[head:head+l], dist='absolute', method='classic', return_path=True)
    s_min = s
    score_start_index = 0
    for i in range(1, len(bar_start)-2):
      l = min(len(input[head:]), bar_start[i+2] - bar_start[i])
      s, path = dtw(score_temp[bar_start[i]:bar_start[i+2]], input_temp[head:head+l], dist='absolute', method='classic', return_path=True)
      if(s < s_min):
        s_min = s
        score_start_index = i
    
    print("score start at bar : ", score_start_index)
    score_start = bar_start[score_start_index]

    s, path = dtw(score_temp[score_start:], input_temp[head:], dist='absolute', method='classic', return_path=True)

    end = len(path[0])
    for i in range(gap):
      lst[0].append(path[0][i] + score_start)
      lst[1].append(path[1][i] + head)

    for i in range(gap, len(path[0])):
      y_diff = abs(path[1][i] - path[1][i-gap])
      x_diff = abs(path[0][i] - path[0][i-gap])
      slope = -1
      if(x_diff != 0):
        slope = y_diff / x_diff

      if(slope < constraint or slope > (1/constraint)):
        end = i
        break
      
    for i in range(gap, end):
      lst[0].append(path[0][i] + score_start)
      lst[1].append(path[1][i] + head)

    head += path[1][end-1]
    if(len(input[head:]) <= one_bar):
      for i in range(end, len(input[head:])):
        lst[0].append(path[0][i] + score_start)
        lst[1].append(path[1][i] + head)
      finish = True
    print()

  return lst

x = dtw_path2(score, score_d, input, 5, 0.6)

n_timestamps_1 = len(score)
n_timestamps_2 = len(input)
plt.figure(figsize=(10, 8))
timestamps_1 = np.arange(n_timestamps_1 + 1)
timestamps_2 = np.arange(n_timestamps_2 + 1)
matrix_classic = np.zeros((n_timestamps_1, n_timestamps_2))
matrix_classic[tuple(x)] = 1.

plt.subplot(2, 2, 1)
plt.pcolor(timestamps_2, timestamps_1, matrix_classic, edgecolors='k', cmap='Greys')
plt.xlabel('x', fontsize=12)
plt.ylabel('y', fontsize=12)

n_timestamps_1 = len(score)
n_timestamps_2 = len(input)
plt.figure(figsize=(10, 8))
timestamps_1 = np.arange(n_timestamps_1 + 1)
timestamps_2 = np.arange(n_timestamps_2 + 1)

# Dynamic Time Warping: classic
dtw_classic, path_classic = dtw(score[bar_start[0]:], input[:], dist='absolute', method='classic', return_path=True)
matrix_classic = np.zeros((n_timestamps_1, n_timestamps_2))
matrix_classic[tuple(path_classic)] = 1.

plt.subplot(2, 2, 1)
plt.pcolor(timestamps_2, timestamps_1, matrix_classic, edgecolors='k', cmap='Greys')
plt.xlabel('x', fontsize=12)
plt.ylabel('y', fontsize=12)
plt.title("{0}\nDTW(x, y) = {1:.2f}".format('classic', dtw_classic), fontsize=14)

print(len(path_classic[0]))

def trim(x):
  lst = []
  for i in range(len(x[1])-1):
    if(x[1][i] != x[1][i+1]):
      lst.append(x[0][i])
      # print(i)
  lst.append(x[0][len(x[1])-1])  
  return lst
  
x = trim(path_classic)
print(len(x))

def forward(score, input):
  row_num = len(score)
  col_num = len(input)
  # print(row_num, col_num)
  cost = np.zeros((row_num, col_num))

  for i in range(row_num):
    for j in range(col_num):
      cost[i][j] = abs(score[i] - input[j])
  
  lst = [[], []]
  c_point = [0, 0]
  # print([row_num-1, col_num-1])
  while(c_point != [row_num-1, col_num-1]):
    lst[0].append(c_point[0])
    lst[1].append(c_point[1])
    c_row = c_point[0]
    c_col = c_point[1]

    row_inc = c_row+1
    if(row_inc == row_num):
      c_point = [c_row, c_col+1]
      continue      

    col_inc = c_col+1
    if(col_inc == col_num):
      c_point = [c_row+1, c_col]
      continue
    

    #print(c_row, c_col, row_inc, col_inc)
    cost_array = [cost[row_inc, c_col], cost[c_row, col_inc], cost[row_inc, col_inc]]
    
    a = np.array(cost_array)
    
    index = np.argmin(a)
    if(a[index] == a[2]):
      index = 2

    if(index == 0):
      c_point = [row_inc, c_col]
    elif(index == 1):
      c_point = [c_row, col_inc]
    else:
      c_point = [row_inc, col_inc]

    # print(c_point)

  lst[0].append(c_point[0])
  lst[1].append(c_point[1])
  #print(lst)  
  return lst

# from tables import path
def not_dtw_QQ(score, score_d, input, gap, constraint):
  lst = [[], []]
  finish = False
  score_temp = score.copy()
  input_temp = input.copy()

  bar_start = []

  thr = 0 
  for i in range(len(score_d)):  
    if(score_d[i] >= thr):
      bar_start.append(i) # 加一個終止?
      thr += 3
  bar_start.append(len(score))
  
  print(bar_start)
  two_bar = -1
  one_bar = -1

  for i in range(len(bar_start) - 2):
    l = bar_start[i+2] - bar_start[i]
    if(l > two_bar):
      two_bar = l

  for i in range(len(bar_start) - 1):
    l = bar_start[i+1] - bar_start[i]
    if(l > one_bar):
      one_bar = l


  print("max num in 2 bars : ", two_bar)
  
  
  input_start = 0
  score_start_index = 0
  
  head = 0
  while(not finish):
    print("input start at : ", head)

    l = min(len(input[head:]), two_bar)
    s, path = dtw(score_temp[bar_start[0]:bar_start[2]], input_temp[head:head+l], dist='absolute', method='classic', return_path=True)
    s_min = s
    score_start_index = 0
    for i in range(1, len(bar_start)-2):
      l = min(len(input[head:]), bar_start[i+2] - bar_start[i])
      s, path = dtw(score_temp[bar_start[i]:bar_start[i+2]], input_temp[head:head+l], dist='absolute', method='classic', return_path=True)
      if(s < s_min):
        s_min = s
        score_start_index = i
    
    print("score start at bar : ", score_start_index)
    score_start = bar_start[score_start_index]

    # s, path = dtw(score_temp[score_start:], input_temp[head:], dist='absolute', method='classic', return_path=True)
    path = forward(score_temp[score_start:], input_temp[head:])
    end = len(path[0])
    for i in range(gap):
      lst[0].append(path[0][i] + score_start)
      lst[1].append(path[1][i] + head)

    for i in range(gap, len(path[0])):
      y_diff = abs(path[1][i] - path[1][i-gap])
      x_diff = abs(path[0][i] - path[0][i-gap])
      slope = -1
      if(x_diff != 0):
        slope = y_diff / x_diff

      if(slope < constraint or slope > (1/constraint)):
        end = i
        # print(slope)
        break
    
    for i in range(gap, end):
      lst[0].append(path[0][i] + score_start)
      lst[1].append(path[1][i] + head)

    head += path[1][end-1]
    print("last : ", head)
    if(len(input[head:]) <= one_bar):
      for i in range(end, len(input[head:])):
        lst[0].append(path[0][i] + score_start)
        lst[1].append(path[1][i] + head)
      finish = True
    print()

  return lst

x = not_dtw_QQ(score, score_d, input, 5, 0.2)
# x = forward(score, input)
print(x)
n_timestamps_1 = len(score)
n_timestamps_2 = len(input)
plt.figure(figsize=(10, 8))
timestamps_1 = np.arange(n_timestamps_1 + 1)
timestamps_2 = np.arange(n_timestamps_2 + 1)
matrix_classic = np.zeros((n_timestamps_1, n_timestamps_2))
matrix_classic[tuple(x)] = 1.

plt.subplot(2, 2, 1)
plt.pcolor(timestamps_2, timestamps_1, matrix_classic, edgecolors='k', cmap='Greys')
plt.xlabel('x', fontsize=12)
plt.ylabel('y', fontsize=12)

s = bar_start[10]
x = forward(score[s:], input[44:])
print(x)
n_timestamps_1 = len(score)
n_timestamps_2 = len(input)
plt.figure(figsize=(10, 8))
timestamps_1 = np.arange(n_timestamps_1 + 1)
timestamps_2 = np.arange(n_timestamps_2 + 1)
matrix_classic = np.zeros((n_timestamps_1, n_timestamps_2))
matrix_classic[tuple(x)] = 1.

plt.subplot(2, 2, 1)
plt.pcolor(timestamps_2, timestamps_1, matrix_classic, edgecolors='k', cmap='Greys')
plt.xlabel('x', fontsize=12)
plt.ylabel('y', fontsize=12)

